// Generated by CoffeeScript 1.10.0
var exec, execSync, isArray, isFunction, isString, parallel, ref, ref1, serial;

exec = require('./exec');

execSync = require('./execSync');

ref = require('./flow'), parallel = ref.parallel, serial = ref.serial;

ref1 = require('./utils'), isArray = ref1.isArray, isFunction = ref1.isFunction, isString = ref1.isString;

module.exports = function(cmds, opts, cb) {
  var err, executor, flow, out, ref2;
  if (isString(cmds)) {
    cmds = (cmds.split('\n')).filter(function(c) {
      return c !== '';
    });
  }
  if (!isArray(cmds)) {
    cmds = [cmds];
  }
  if (isFunction(opts)) {
    ref2 = [opts, {}], cb = ref2[0], opts = ref2[1];
  }
  if (opts == null) {
    opts = {};
  }
  executor = exec;
  flow = serial;
  if (opts.sync) {
    executor = execSync;
  }
  if (opts.parallel) {
    flow = parallel;
  }
  if (cb && isFunction(cb)) {
    return flow(executor, cmds, opts, cb);
  }
  if (opts.sync) {
    out = '';
    err = '';
    return flow(executor, cmds, opts, function(err, stdout, stderr, status) {
      if (!opts.syncThrows) {
        return;
      }
      if (opts.strict && status !== 0) {
        throw err;
      } else if ((err != null) && (status == null)) {
        throw err;
      }
    });
  }
  return new Promise(function(resolve, reject) {
    return flow(executor, cmds, opts, function(err, stdout, stderr, status) {
      if (opts.strict && status !== 0) {
        return reject(err);
      } else if ((err != null) && (status == null)) {
        return reject(err);
      }
      return resolve({
        stdout: stdout,
        stderr: stderr,
        status: status
      });
    });
  });
};

//# sourceMappingURL=executive.js.map
